Easy Analysis for WESTPA simulation data
Use once all full iterations qsubbed have completed
OR if iterations are running, you can use -W westBackup.h5, USE CAUTION

-----------------------------------------------------------------
# Bin information for last run
w_bins info --detail # > bins.log
w_bins info --detail --bins-from-system > bins.log

-----------------------------------------------------------------
# Create histogram of progress coordinates and probability distribution
w_pdist -W ../west.h5
plothist average pdist.h5 0::'MinDist (Å)' 1::'RMSD (Å)' -o avg.pdf
plothist evolution pdist.h5 1::'RMSD (Å)' -o histRMSD.pdf
plothist evolution pdist.h5 0::'MinDist (Å)' -o histMinDist.pdf

-----------------------------------------------------------------
# Start interactive python analysis
w_ipa
import contextlib
from IPython.lib.pretty import pretty
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# -----------------------------------------------------------------
# Check bin bounds and state labels as defined in west.cfg analysis scheme
w.bin_labels
w.state_labels

# -----------------------------------------------------------------
# To identify segments in target bin as defined in west.cfg analysis scheme
# Change == 0 to == 1, as needed for correct bins

targetBin = 0
indices = np.where(w.current.bins[:,1] == targetBin)[0]
print('Num. segments in bin:', len(indices))
print('Indecies of occupied bins:', indices,'\n')

# Get all segment IDs in desired bin
seg_id = w.current.seg_id[indices]
print('SegIDs in bin:', seg_id,'\n')

# To identify seg_id with min pcoord value
# Get all pcoords for segment IDs in desired bin
seg_pcoords = w.current.pcoord[indices]
final_pcoords = seg_pcoords[:,-1]  # Use final pcoord value for each segment
final_pcoords = [tuple(row) for row in final_pcoords]

# For 2D pcoords, choose first or second pcoord of interest, or use both
# If choosing 1 of 2 pcoords, filter again based on first or second pcoord

final_pcoords1, final_pcoords2 = map(list, zip(*final_pcoords))

data = {
  "SegID": list(seg_id),
  "Pcoord1": list(final_pcoords1),
  "Pcoord2": list(final_pcoords2)
}

data = pd.DataFrame(data)
data = data.sort_values('Pcoord2') # Change to tuple index of interest
data.index = list(range(1,len(data)+1))
print(data)

# Find the index of the minimum pcoord value
min_pcoord_index1 = np.argmin(final_pcoords1)
min_pcoord_index2 = np.argmin(final_pcoords2)

# Get the seg_id corresponding to the minimum pcoord

min_pcoord1_seg_id = seg_id[min_pcoord_index1]
min_pcoord1_value = final_pcoords1[min_pcoord_index1]

min_pcoord2_seg_id = seg_id[min_pcoord_index2]
min_pcoord2_value = final_pcoords2[min_pcoord_index2]

print(f"Segment ID with minimum 1st pcoord: {min_pcoord1_seg_id}")
print(f"Minimum 1st pcoord value: {min_pcoord1_value}")

print(f"Segment ID with minimum 2nd pcoord: {min_pcoord2_seg_id}")
print(f"Minimum 2nd pcoord value: {min_pcoord2_value}")

# -----------------------------------------------------------------
# To identify segments that transitioned to target bin in last iteration
# Change to any direction needed, eg. [(0,1)] (folded -> unfolded)

try:
  result = w.current.successful_trajectories[(1,0)] # Unfolded -> folded
  print('Segments transitioned to target bin in iteration '+ str(w.iteration))
  print('-----------------------------------------------------------------')
  print(result)
except KeyError:
  print('No segments transitioned in iteration ' + str(w.iteration))



# ----------------------------------------------------------------------------------------------------------------------------------

# Write bin, state labels, segIDs + pcoords, rate evolution, and target flux evolution logfile

with open('analysis/w_ipa.log', 'w') as file:
  with contextlib.redirect_stdout(file):

        print('-----------------------------------------------------------------')
        print('Bin and State Labels')
        print('-----------------------------------------------------------------')
        w.bin_labels
        print('\n')
        w.state_labels
        print('\n')

        print('-----------------------------------------------------------------')
        print('Target bin: ', targetBin)
        print('\n')
        print('Successful Segments in Target Bin: ' + str(len(data)))
        print('-----------------------------------------------------------------')
        print(data.to_string())
        print('\n')

        print('-----------------------------------------------------------------')
        try:
          result = w.current.successful_trajectories[(1,0)]
          print('Segments transitioned to target bin in iteration '+ str(w.iteration))
          print('-----------------------------------------------------------------')
          print(result)
        except KeyError:
          print('No segments transitioned in iteration ' + str(w.iteration))
          print('-----------------------------------------------------------------')
        print('\n')

        print('-----------------------------------------------------------------')
        print('Minimum PCoords for iteration ' +str(w.iteration))
        print('-----------------------------------------------------------------')
        print(f"Segment ID with minimum 1st pcoord: {min_pcoord1_seg_id}")
        print(f"Minimum 1st pcoord value: {min_pcoord1_value}")
        print('\n')
        print(f"Segment ID with minimum 2nd pcoord: {min_pcoord2_seg_id}")
        print(f"Minimum 2nd pcoord value: {min_pcoord2_value}")
        print('\n')

        print('-----------------------------------------------------------------')
        print('Rate Evolution')
        print('-----------------------------------------------------------------')
        print(pretty(w.current.direct.rate_evolution) + '\n')
        plt.plot(w.direct['rate_evolution']['expected'][:, 1, 0], color='purple')
        plt.plot(w.direct['rate_evolution']['ci_ubound'][:, 1, 0], color='grey')
        plt.plot(w.direct['rate_evolution']['ci_lbound'][:, 1, 0], color='grey')
        plt.xlabel('Iteration')
        plt.ylabel(u'unfolded → folded rate (1/\u03c4)')
        plt.savefig("analysis/rateevolution.png")
        plt.close()
        print('Rate Evolution plot saved as rateevolution.png \n\n')

        print('-----------------------------------------------------------------')
        print('Target Flux Evolution')
        print('-----------------------------------------------------------------')
        print(pretty(w.current.direct.target_flux_evolution) + '\n')
        plt.plot(w.direct['target_flux_evolution']['expected'][:,0], color='blue')
        plt.plot(w.direct['target_flux_evolution']['ci_lbound'][:,0], color='gray')
        plt.plot(w.direct['target_flux_evolution']['ci_ubound'][:,0], color='gray')
        plt.xlabel('Iteration')
        plt.ylabel(u'Mean Flux into Folded (1/\u03c4)')
        plt.savefig("analysis/fluxevolution.png")
        plt.close()
        print('Target Flux Evolution plot saved as fluxevolution.png\n\n')
        print('-----------------------------------------------------------------')

-----------------------------------------------------------------
# Direct Rate Evolution
w.current.direct.rate_evolution
w.current.direct.rate_evolution.plot(interface='matplotlib')

# Plot direct rate evolution - change 1, 0 to any bin direction as needed
import matplotlib.pyplot as plt
plt.plot(w.direct['rate_evolution']['expected'][:, 1, 0], color='black')
plt.plot(w.direct['rate_evolution']['ci_ubound'][:, 1, 0], color='grey')
plt.plot(w.direct['rate_evolution']['ci_lbound'][:, 1, 0], color='grey')
plt.xlabel('Iteration')
plt.ylabel(u'unfolded → folded rate (1/\u03c4)')
plt.show()

-----------------------------------------------------------------
# Target Flux evolution
w.current.direct.target_flux_evolution.plot(0)

import matplotlib.pyplot as pyplot
pyplot.plot(w.direct['target_flux_evolution']['expected'][:,0], color='blue')
pyplot.plot(w.direct['target_flux_evolution']['ci_lbound'][:,0], color='gray')
pyplot.plot(w.direct['target_flux_evolution']['ci_ubound'][:,0], color='gray')
pyplot.xlabel('Iteration')
pyplot.ylabel(u'Mean Flux (1/\u03c4)')
pyplot.show()

-----------------------------------------------------------------




barnaba ERMSD --ref ../../../common_files/closest_averagefoldedDES.pdb --trj seg.rst --top struct.prmtop
awk 'NR > 2 {sum += $2; count++} END {print sum/count}' outfile.ERMSD.out

awk '
  NR == 3 {first = $2 + 0}  # The "+ 0" ensures numeric interpretation
  NR > 2 {last = $2 + 0}
  END {
    print first, last
  }
' outfile.ERMSD.out